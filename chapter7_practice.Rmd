---
title: "Untitled"
author: "Hoang-Chau Luong"
date: '2022-09-12'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(rethinking)
library(tidybayes)
library(brms)

theme_set(theme_light())
```

# **Easy**

## **1**

State the three motivating criteria that define information entropy. Try to express each in your own words.

**Answer**

Insight of information entropy is "How much is our uncertainty reduced by learning an outcome? 3 criteria:

1. The measure of uncertainty should be continuous
2. The measure of uncertainty should increase as the number of possible events increases -> Sample set larger -> uncertainty increases
3. The measure of uncertainty should be additive

## **2**

:::quesion
>Suppose a coin is weighted such that, when it is tossed and lands on a table, it comes up heads 70% of the time. What is the entropy of this coin?
:::

**Answer**
```{r}
p_logp <- function(p){
  if(p == 0) return(0)
  p * log(p)
}

calc_entropy <- function(x){
  avg_logprob <- sum(map_dbl(x, p_logp))
  -1 * avg_logprob
}

probs <- c(0.7, 0.3)

calc_entropy(probs)
```

## **3**

:::question
> Suppose a four-sided die is loaded such that, when tossed onto a table, it shows “1” 20%, “2” 25%, “3” 25%, and “4” 30% of the time. What is the entropy of this die?
:::

**Answer**
```{r}
probs <- c(0.2, 0.25, 0.25, 0.3)
calc_entropy(probs)
```

## **4**

:::question
>Suppose another four-sided die is loaded such that it never shows “4.” The other three sides show equally often. What is the entropy of this die
:::

**Answer**
```{r}
probs <- c(1/3, 1/3, 1/3, 0)
calc_entropy(probs)
```

# **Medium**

## **1**

:::question
>Write down and compare the definitions of AIC and WAIC. Which of these criteria is most general? Which assumptions are required to transform the more general criterion into a less general one?
:::

**Answer**
$$
\text{lppd} = \sum_{i}^{n}\text{log}
\int\text{p}(\text{y}_{i}|\theta)\text{p}_{post}(\theta)d\theta
$$

$$
\text{AIC} = \text{-2*llpd + 2p} \\
WAIC(y, \theta) = \text{-2(lppd - }\sum_{i}\text{var}_{\theta}\text{log}p(y_{i}|\theta))
$$

The WAIC is more general than the AIC, as the AIC assumes that priors are flat or overwhelmed by the likelihood, the posterior distribution is approximately multivariate Gaussian, and the sample size is much greater than the number of parameters. If all of these assumptions are met, then we would expect the AIC and WAIC to be about the same. 

## **2**

:::question
>Explain the difference between model selection and model comparison. What information is lost under model selection?
:::

**Answer**
   Model selection refers to just pick the model that has the lowest criterion value and discarding other models. When we take this approach, we lose information about the relative model accuracy that can inform how confident we are in the models
   Additionally, model selection only cares about predictive accuracy and ignores causal inferences. Thus, a model may be selected that has confounds or that would not correctly inform an intervention
   
   In contrast, model comparison uses multiple models to understand about how the variables included influence prediction and affect implied conditional independencies in a causal model
   -> Thus, we can preserve information and can make more hoslistic judgement about the data & models.
   
## **3**

:::question
>When comparing models with an information criterion, why must all models be fit to exactly the same observations? What would happen to the information criterion values, if the models were fit to different numbers of observations? Perform some experiments, if you are not sure.
:::

**Answer**
  If we compare models which is trained on different datasets, then we will get into the inconsistency state. The underlying of comparing something is the same context, the same treatment.

  All of the information criteria are defined based on the log-pointwise-predictive density, defined as follows, where y is the data, $\theta$ is the posterior distribution, S is the number of samples, and I is the number of samples.
  
$$
lppd(y,\theta) = \sum_{i}\text{log}\frac{1}{S}\sum_{s}p(y_{i}|\theta_{s})
$$

  In the words, this means take the log of the average probability across samples of each observation i and sum them together. Thus a larger sample size will necessarily lead to a smaller log-pointwise-predictive-density, even if the data generating process and models are exactly equivalent (i.e., when the lppd values are negative, the sum will get more negative as the sample size increases). More observations are entered into the sum, leading a smaller final lppd, which will in turn increase the information criteria. We can run a quick simulation to demonstrate. For three different sample sizes, we'll simulate 100 data sets from the exact same data generation process, estimate a exact same linear model, and then calculate the lppd, WAIC, and PSIS for each.
  
```{r}
gen_data <- function(n){
  tibble(x1 = rnorm(n)) %>% 
    mutate(y = rnorm(n = n, mean = 0.3 + 0.8 * x1),
           across(everything(), standardize))
}

fit_model <- function(dat) {
  suppressMessages(output <- capture.output(
    mod <- brm(y ~ 1 + x1, data = dat, family = gaussian,
               prior = c(prior(normal(0, 0.2), class = Intercept),
                         prior(normal(0, 0.5), class = "b"),
                         prior(exponential(1), class = sigma)),
               iter = 4000, warmup = 2000, chains = 4, cores = 4, seed = 123)
  ))
  
  return(mod)
}


calc_info <- function(model) {
  mod_lppd <- log_lik(model) %>% 
    as_tibble(.name_repair = "minimal") %>% 
    set_names(paste0("obs_", 1:ncol(.))) %>% 
    rowid_to_column(var = "iter") %>% 
    pivot_longer(-iter, names_to = "obs", values_to = "logprob") %>% 
    mutate(prob = exp(logprob)) %>% 
    group_by(obs) %>% 
    summarize(log_prob_score = log(mean(prob))) %>% 
    pull(log_prob_score) %>% 
    sum()
  
  mod_waic <- suppressWarnings(waic(model)$estimates["waic", "Estimate"])
  mod_psis <- suppressWarnings(loo(model)$estimates["looic", "Estimate"])
  
  tibble(lppd = mod_lppd, waic = mod_waic, psis = mod_psis)
}

sample_sim <- tibble(sample_size = rep(c(100, 500, 1000), each = 100)) %>%
  mutate(sample_data = purrr::map(sample_size, gen_data),
         model = purrr::map(sample_data, fit_model),
         infc = purrr::map(model, calc_info)) %>%
  select(-sample_data, -model) %>% 
  unnest(infc) 
```

```{r}
library(ggridges)

sample_sim %>%
  pivot_longer(cols = c(lppd, waic, psis)) %>%
  mutate(sample_size = fct_inorder(as.character(sample_size)),
         name = str_to_upper(name),
         name = fct_inorder(name)) %>%
  ggplot(aes(x = value, y = sample_size)) +
  facet_wrap(~name, nrow = 1, scales = "free_x") +
  geom_density_ridges(bandwidth = 4) +
  scale_y_discrete(expand = c(0, .1)) +
  scale_x_continuous(breaks = seq(-2000, 3000, by = 750)) +
  coord_cartesian(clip = "off") +
  labs(x = "Value", y = "Sample Size")
```
  

## **4**

:::question
>What happens to the effective number of parameters, as measured by PSIS or WAIC, as a prior becomes more concentrated? Why? Perform some experiments, if you are not sure.
:::

**Answer**
$$
\text{lppd} = \sum_{i}^{n}\text{log}
\int\text{p}(\text{y}_{i}|\theta)\text{p}_{post}(\theta)d\theta
$$

$$
\text{AIC} = \text{-2*llpd + 2p} \\
WAIC(y, \theta) = \text{-2(lppd - }\sum_{i}\text{var}_{\theta}\text{log}p(y_{i}|\theta))
$$

  Smaller variances in log probabilities will results in a lower penalty. If we restrict the prior to become more concentrated, we restrict the plausible range of the parameters. In other words, we restrict the variability in the posterior distribution. As the parameters become more consistent, the log probability of each observation will necessarily become more consistent also. Thus, the penalty term, or effective number of parameters, becomes smaller. We can again confirm with a small simulation


## **5**

:::question
>Provide an informal explanation of why informative priors reduce overfitting.
:::

**Answer**
   Informative priors restrict the plausible values for parameters. By using informative priors, we can limit the values of parameters to values that are reasonable, given our scientific knowledge. Thus, we can keep the model from learning too much from our specific sample.


## **6**

:::question
> Provide an informal explanation of why overly informative priors result in underfitting.
:::

**Answer**
   In contrast to the previous question, making the prior too informative can be too restrictive on the parameter space. This prevents our model from learning enough from our sample. We basically just get our prior distributions back, without learning anything from the data that could help make future predictions.

# **Hard**

## **1**

:::question
>In 2007, The Wall Street Journal published an editorial (“We’re Number One, Alas”) with a graph of corportate tax rates in 29 countries plotted against tax revenue. A badly fit curve was drawn in (reconstructed at right), seemingly by hand, to make the argument that the relationship between tax rate and tax revenue increases and then declines, such that higher tax rates can actually produce less tax revenue. I want you to actually fit a curve to these data, found in `data(Laffer)`. Consider models that use tax rate to predict tax revenue. Compare, using WAIC or PSIS, a straight-line model to any curved models you like. What do you conclude about the relationship between tax rate and tax revenue.
:::

```{r}
data(Laffer)
df <- Laffer

df %>% 
  as_tibble() %>% 
  ggplot(aes(x = tax_rate, y = tax_revenue)) +
  geom_point()

df <- df %>% 
  mutate(across(everything(), standardize),
         tax_rate2 = tax_rate^2)

laf_line <- brm(tax_revenue ~ 1 + tax_rate, 
                data = df, family = gaussian,
                prior = c(prior(normal(0, 0.2), class = Intercept),
                          prior(normal(0, 0.5), class = b),
                          prior(exponential(1), class = sigma)),
                iter = 1000, warmup = 500, chains = 4, cores = 4, seed = 123,
                file = here::here("fits", "chp7", "b7h1-line.rds"))

laf_quad <- brm(tax_revenue ~ 1 + tax_rate + tax_rate2, 
                data = df, family = gaussian,
                prior = c(prior(normal(0, 0.2), class = Intercept),
                          prior(normal(0, 0.5), class = b),
                          prior(exponential(1), class = sigma)),
                iter = 1000, warmup = 500, chains = 4, cores = 4, seed = 123,
                file = here::here("fits", "chp7", "b7h1-quad.rds"))
# spine
laf_spln <- brm(tax_revenue ~ 1 + s(tax_rate, bs = "bs"),
                data = df, family = gaussian,
                prior = c(prior(normal(0, 0.2), class = Intercept),
                          prior(normal(0, 0.5), class = b),
                          prior(normal(0, 0.5), class = sds),
                          prior(exponential(1), class = sigma)),
                iter = 1000, warmup = 500, chains = 4, cores = 4, seed = 123,
                control = list(adapt_delta = 0.95),
                file = here::here("fits", "chp7", "b7h1-spln.rds"))

laf_line <- readRDS(here::here("fits", "chp7", "b7h1-line.rds"))
laf_quad <- readRDS(here::here("fits", "chp7", "b7h1-quad.rds"))
laf_spln <- readRDS(here::here("fits", "chp7", "b7h1-spln.rds"))
```

```{r}
library(wjake)

tr_seq <- tibble(tax_rate = seq(0, 40, length.out = 100)) %>% 
  mutate(tax_rate = (tax_rate - mean(Laffer$tax_rate)) / sd(Laffer$tax_rate),
         tax_rate2 = tax_rate^2)

predictions <- bind_rows(
  predicted_draws(laf_line, newdata = tr_seq) %>% 
    median_qi(.width = 0.89) %>% 
    mutate(type = "Linear"),
  predicted_draws(laf_quad, newdata = tr_seq) %>%
    median_qi(.width = 0.89) %>%
    mutate(type = "Quadratic"),
  predicted_draws(laf_spln, newdata = tr_seq) %>%
    median_qi(.width = 0.89) %>%
    mutate(type = "Spline")
)

fits <- bind_rows(
  epred_draws(laf_line, newdata = tr_seq) %>%
    median_qi(.width = c(0.67, 0.89, 0.97)) %>%
    mutate(type = "Linear"),
  epred_draws(laf_quad, newdata = tr_seq) %>%
    median_qi(.width = c(0.67, 0.89, 0.97)) %>%
    mutate(type = "Quadratic"),
  epred_draws(laf_spln, newdata = tr_seq) %>%
    median_qi(.width = c(0.67, 0.89, 0.97)) %>%
    mutate(type = "Spline")
)

ggplot() +
  facet_wrap(~type, nrow = 1) +
  geom_ribbon(data = predictions,
              aes(x = tax_rate, ymin = .lower, ymax = .upper),
              alpha = 0.2) +
  geom_lineribbon(data = fits,
                  aes(x = tax_rate, y = .epred, ymin = .lower, ymax = .upper),
                  size = 0.6) +
  geom_point(data = df, aes(x = tax_rate, y = tax_revenue),
             alpha = 0.5) +
  scale_fill_manual(values = ramp_blue(seq(0.9, 0.1, length.out = 3)),
                    breaks = c(0.67, 0.89, 0.97)) +
  labs(x = "Standardized Tax Rate", y = "Standardized Tax Revenue",
       fill = "Interval")
```

They all look pretty similar, but the quadratic and spline models do show a slight curve. Next, we can look at the PSIS (called LOO in {brms} and {rstan}) and WAIC comparisons. Neither the PSIS or WAIC is really able to differentiate the models in a meaningful way. However, it should be noted that both the PSIS and WAIC have Pareto or penalty values that are exceptionally large, which could make the criteria unreliable.

```{r}
library(loo)

laf_line <- add_criterion(laf_line, criterion = c("loo", "waic"))
laf_quad <- add_criterion(laf_quad, criterion = c("loo", "waic"))
laf_spln <- add_criterion(laf_spln, criterion = c("loo", "waic"))

loo_compare(laf_line, laf_quad, laf_spln, criterion = "waic")
#>          elpd_diff se_diff
#> laf_quad  0.0       0.0   
#> laf_spln -0.1       0.6   
#> laf_line -0.9       0.9
loo_compare(laf_line, laf_quad, laf_spln, criterion = "loo")
#>          elpd_diff se_diff
#> laf_spln  0.0       0.0   
#> laf_quad  0.0       0.7   
#> laf_line -0.8       0.9
```


## **2**

:::question
>In the Laffer data, there is one country with a high tax revenue that is an outlier. Use PSIS and WAIC to measure the importance of this outlier in the models you fit in the previous problem. Then use robust regression with a Student’s t distribution to revist the curve fitting problem. How much does a curved relationship depend upon the outlier point.
:::

```{r}
library(gghighlight)

criteria_influence <- function(mod) {
  tibble(pareto_k = mod$criteria$loo$diagnostics$pareto_k,
         p_waic = mod$criteria$waic$pointwise[, "p_waic"]) %>% 
    rowid_to_column(var = "obs")
}

influ <- bind_rows(
  criteria_influence(laf_line) %>% 
    mutate(type = "Linear"),
  criteria_influence(laf_quad) %>% 
    mutate(type = "Quadratic"),
  criteria_influence(laf_spln) %>% 
    mutate(type = "Spline")
)

influ %>% 
  ggplot(aes(x = pareto_k, y = p_waic)) +
  facet_wrap(~ type, nrow = 1) +
  geom_vline(xintercept = 0.7, linetype = "dashed") +
  geom_hline(yintercept = 0.4, linetype = "dashed") +
  geom_point() +
  gghighlight(pareto_k > 0.7 | p_waic > 0.4, n = 1, label_key = obs,
              label_params = list(size = 3)) +
  labs(x = "Pareto *k*", y = "p<sub>WAIC</sub>")
```

Let’s refit the model using a Student’s t distribution to put larger tails on our outcome distribution, and then visualize our new models.

```{r}
laf_line2 <- brm(bf(tax_revenue ~ 1 + tax_rate, nu = 1),
                 data = df, family = student,
                 prior = c(prior(normal(0, 0.2), class = Intercept),
                           prior(normal(0, 0.5), class = b),
                           prior(exponential(1), class = sigma)),
                 iter = 4000, warmup = 2000, chains = 4, cores = 4, seed = 123,
                 file = here::here("fits", "chp7", "b7h2-line.rds"))

laf_quad2 <- brm(bf(tax_revenue ~ 1 + tax_rate + tax_rate2, nu = 1),
                 data = df, family = student,
                 prior = c(prior(normal(0, 0.2), class = Intercept),
                           prior(normal(0, 0.5), class = b),
                           prior(exponential(1), class = sigma)),
                 iter = 4000, warmup = 2000, chains = 4, cores = 4, seed = 123,
                 file = here::here("fits", "chp7", "b7h2-quad.rds"))

laf_spln2 <- brm(bf(tax_revenue ~ 1 + s(tax_rate, bs = "bs"), nu = 1),
                 data = df, family = student,
                 prior = c(prior(normal(0, 0.2), class = Intercept),
                           prior(normal(0, 0.5), class = b),
                           prior(exponential(1), class=  sigma)),
                 iter = 4000, warmup = 2000, chains = 4, cores = 4, seed = 123,
                 file = here::here("fits", "chp7", "b7h2-spln.rds"))

predictions <- bind_rows(
  predicted_draws(laf_line2, newdata = tr_seq) %>% 
    median_qi(.width = 0.89) %>% 
    mutate(type = "Linear"),
  predicted_draws(laf_quad2, newdata = tr_seq) %>% 
    median_qi(.width = 0.89) %>% 
    mutate(type = "Quadratic"),
  predicted_draws(laf_spln2, newdata = tr_seq) %>% 
    median_qi(.width = 0.89) %>% 
    mutate(type = "Spline")
)


# epred_draws -> 
fits <- bind_rows(
  add_epred_draws(laf_line2, newdata = tr_seq) %>% 
    median_qi(.width = c(0.67, 0.89, 0.97)) %>% 
    mutate(type = "Linear"),
  add_predicted_draws(laf_quad2, newdata = tr_seq) %>% 
    median_qi(.width = c(0.67, 0.89, 0.97)) %>% 
    mutate(type = "Quadratic"),
  add_predicted_draws(laf_spln2, newdata = tr_seq) %>% 
    median_qi(.width = c(0.67, 0.89, 0.97)) %>% 
    mutate(type = "Spline")
)

ggplot() +
  facet_wrap(~type, nrow = 1) +
  geom_ribbon(data = predictions, 
              aes(x = tax_rate, ymin = .lower, ymax = .upper),
              alpha = 0.2) +
  geom_lineribbon(data = fits,
                  aes(x = tax_rate, y = .epred, ymin = .lower, ymax = .upper),
                  alpha = 0.6) +
  geom_point(data = df, aes(x = tax_rate, y = tax_revenue),
             alpha = 0.5) +
  scale_fill_manual(values = ramp_blue(seq(0.9, 0.1, length.out = 3)),
                    breaks = c(0.67, 0.89, 0.97)) +
  labs(x = "Standardized Tax Rate", y = "Standardized Tax Revenue",
       fill = "Interval")
```

The prediction intervals are a little bit narrower, which makes sense as the predictions are no longer being as influenced by the outlier. When we look at the new PSIS and WAIC estimates, we are no longer getting warning messages about large Pareto k values; however, we do still see warnings about large $p_{WAIC}$ values. The comparisons also tell the same story as before, with no distinguishable differences between the models.

```{r}

influ2 <- bind_rows(
  criteria_influence(laf_line2) %>% 
    mutate(type = "Linear"),
  criteria_influence(laf_quad2) %>% 
    mutate(type = "Quadratic"),
  criteria_influence(laf_spln2) %>% 
    mutate(type = "Spline")
)


```
























